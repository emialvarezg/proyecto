# -*- coding: utf-8 -*-
"""recomendaciones v2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UL_heyXcedFAtCWFB6h4l8TyWGvzXCvC
"""

pip install spotipy --upgrade

import os
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
import numpy as np
import networkx as nx
import random
import statistics
import matplotlib.pyplot as plt
from collections import Counter

os.environ['SPOTIPY_CLIENT_ID'] ='ed651235a94342d1b3bcdf3ab85692d3'
os.environ ['SPOTIPY_CLIENT_SECRET']='3790e770a3a84bdc95ba458dbbf7d937'

sp = spotipy.Spotify(client_credentials_manager=SpotifyClientCredentials())

# función f para ajustar recomendaciones respecto a un parámetro a
def f(p,a):
  if a==0 or p==0:
    return 1
  if a>0:
    return (p**a)/(100**a)
  else:
    return p**a

#Aquí guarden como variables todos los artistas que quieran usar
#ejemplo 
#si el link es 
link = 'https://open.spotify.com/artist/3PP6ghmOlDl2jaKaH0avUN?si=51_amCT-TU-CHtMrj7EfIQ'
#definan
bcnr = 'spotify:artist:3PP6ghmOlDl2jaKaH0avUN?si=51_amCT-TU-CHtMrj7EfIQ' #-0.4 0.4
juanaMol = 'spotify:artist:76hliHkgP5eIbVqLT7NmQ3?si=51_amCT-TU-CHtMrj7EfIQ'
bh = 'spotify:artist:56ZTgzPBDge0OvCGgMO3OY?si=49ywZQ-_R5aR96c06Vk4qw' #-0.5,0.6
swans = 'spotify:artist:79S80ZWgVhIPMCHuvl6SkA?si=hfBYkqCrSIqSbFtLacS2xw'
cp = 'spotify:artist:4Ge8xMJNwt6EEXOzVXju9a?si=3HWIhlbSS1OyMVJPgxXShA' #-0.5, 0.5
björk = 'spotify:artist:7w29UYBi0qsHi5RTcv3lmA?si=xoCxuA73QS-CeXFokgi9UQ'
billie = 'spotify:artist:6qqNVTkY8uBg9cP3Jd7DAH?si=BxuqVYG3QWiJOY346umyqg' #-0.4, 0.7
mcr = 'spotify:artist:7FBcuc1gsnv6Y1nwFtNRCb?si=O_r2H39sQUyxtMSnq0lLSw'
bm = 'spotify:artist:7Hvq85OU8T7Hsd63zNBwaL?si=I5OFhlsaQqGBbiNN8CmJZw' #-0.7 0.7

#ingresar artista
recs=sp.artist_related_artists(billie)

#seleccionar a (preferentemente -1 < a < 1, recomiendo valores cercanos a 0)
# a<0 hace más probable obtener recomendaciones menos populares, a>0 regresa artistas más populares (respecto al inicial)
a=0

#vértices
vertices=[]
for i in range(len(recs['artists'])):
  vertices.append({'name':recs['artists'][i]['name'],'popularity':recs['artists'][i]['popularity'],'uri':recs['artists'][i]['uri']})
  links=[]
#print(len(vertices))
for artist in vertices:
  if np.random.uniform() < f(artist['popularity'],a): #con esta condición se seleccionan menos artistas relacionados
  #if np.random.uniform() < 1-(artist['popularity']/100):
    links.append(artist['uri'])
print(len(links))
for l in links:
  recs=sp.artist_related_artists(l)
  for i in range(len(recs['artists'])):
    vertices.append({'name':recs['artists'][i]['name'],'popularity':recs['artists'][i]['popularity'],'uri':recs['artists'][i]['uri']})
print(len(vertices))
#quitamos repetidos
vert = []
for i in vertices:
  if i not in vert:
    vert.append(i) 
print(len(vert))


#función para obtener información de un artista seleccionado
def info(name,info):
  for artist in vert:
    if artist['name'] == name:
      return artist[info]

#construimos la gráfica con los vértices y aristas previamente seleccionados
G= nx.complete_graph([artist['name'] for artist in vert])
print(G,nx.is_connected(G))

#función para definir vector de probabilidades para un vértice considerando popularidad
def vect_prob(vertice):
  v = list(G.neighbors(vertice))
  prob=[]
  for vec in v:
    pop=info(vec,'popularity')
    prob.append(f(pop,a))
  return [(1/sum(prob))*i for i in prob]

#caminata aleatoria
n=10000
burn=2000
v_0 = random.choices(list(G.nodes()))[0]
vertices_visitados = [v_0]
for i in range(n):
  p=vect_prob(v_0)
  v = random.choices(list(G.neighbors(v_0)),weights=p)[0]
  vertices_visitados.append(v)
  v_0=v

vertices_visitados
frec = Counter(vertices_visitados[burn:])
frecuencia= dict(frec)
#frecuencia
pi=[]
for v in list(G.nodes()):
  if v in frecuencia:
    pi.append(frecuencia[v])
  else:
    pi.append(0)
d_est = [(1/(n-burn))*i for i in pi]
print(sum(d_est))

#Cada que corran este bloque regresa una recomendación 
rec = random.choices(list(G.nodes()),weights=d_est)[0]
print(rec,info(rec,'popularity'))
print('link:',info(rec,'uri'))
frecuencia[rec]

orden = sorted([[frecuencia[list(G.nodes())[i]], list(G.nodes())[i], (n-burn)*d_est[i]] for i in range(len(list(G.nodes())))],reverse=True)
dic_orden = {}
for i in range(len(orden)):
  dic_orden[orden[i][1]]=i+1
#dic_orden
#orden

muestra = [random.choices(list(G.nodes()),weights=d_est)[0] for i in range(n-burn)]
frec_muestra = dict(Counter(muestra))

muestra_ord=dict(sorted(frec_muestra.items(), key = lambda item: item[1],reverse=True))
muestra_ord
lista1=[]
lista2=[]
lista3=[]
lista4=[]
for i in dic_orden:
  if i in muestra_ord:
    lista1.append(dic_orden[i])
    lista2.append(muestra_ord[i])
    lista3.append(frecuencia[i])
    lista4.append(info(i,'popularity'))

plt.scatter(lista1,lista3),plt.scatter(lista1,lista4)
plt.title('Frecuencia y popularidad')
plt.xlabel('Vértices ordenados')

plt.scatter(lista1,lista2),plt.scatter(lista1,lista4)
plt.title('Muestra y popularidad')
plt.xlabel('Vértices ordenados')